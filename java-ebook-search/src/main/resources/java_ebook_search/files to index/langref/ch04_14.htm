
[Chapter 4] 4.14 Order of Operations
Chapter 4Expressions
4.14 Order of Operations
In an expression
that contains multiple operators, Java uses a number of rules to
decide the order in which the operators are evaluated. The first
and most important rule is called operator precedence.
Operators in an expression that have higher precedence are executed
before operators with lower precedence. For example, multiplication
has a higher precedence than addition. In the expression 2+3*4,
the multiplication is done before the addition, producing a result
of 14.
If consecutive operators in an expression have
the same precedence, a rule called associativity is
used to decide the order in which those operators are evaluated.
An operator can be left-associative, right-associative, or non-associative:
Left-associative operators of the same precedence are evaluated
in order from left to right. For example, addition and subtraction
have the same precedence and they are left-associative. In the expression
10-4+2, the subtraction is done first because
it is to the left of the addition, producing a value of 8.
Right-associative operators of the same precedence are evaluated in order
from right to left. For example, assignment is right-associative.
Consider the following code fragment:
int a = 3;
int b = 4;
a = b = 5;
After the code has been evaluated,
both a and b contain 5 because
the assignments are evaluated from right to left.
A
non-associative operator cannot be combined with other operators
of the same precedence.
Table 4-2 shows the precedence
and associativity of all the operators
in Java.[7]
[7] 
Although the
precedence of operators in Java is similar to that in C++, there
are some differences. For example, new has a
higher precedence in Java than it does in C++. Another difference
is that the ++ and - - operators
are effectively non-associative in Java.
Table 4.2: Precedence and Associativity of Operators in Java
Precedence
Operator
Associativity
1
(), []
non-associative
2
new
non-associative
3
.
left-associative
4
++, - -
non-associative
5
- (unary), + (unary),
!, ~, ++,
- -, 
(type)
right-associative
6
*, /,
%
left-associative
7
+, -
left-associative
8
&lt;&lt;, &gt;&gt;,
&gt;&gt;&gt;
left-associative
9
&lt;, &gt;,
&lt;=, &gt;=,
instanceof
non-associative
10
==, !=
left-associative
11
&amp;
left-associative
12
^
left-associative
13
|
left-associative
14
&amp;&amp;
left-associative
15
||
left-associative
16
?:
right-associative
17
=, *=, 
/=,
%=, -=, &lt;&lt;=,
&gt;&gt;=, &gt;&gt;&gt;=,
&amp;=, ^=, |=
right-associative
As in C/C++, the order in which operators
are evaluated can be modified by the use of parentheses.
The
rest of the rules that concern order of operations have to do with
the evaluation of operands or arguments in a single expression.
The left operand of a binary operator is evaluated
before its right operand.
The operands of an operator
are evaluated before the operator is evaluated. Consider the following
expression:
((x=4) * x)
First, the left
operand of * is evaluated; it produces the 
value 4. Then the right operand of *
is evaluated. Since evaluation of the left operand
set x to 4, evaluation of the right operand 
produces 4. Finally, the * operator itself is
evaluated, producing the value 16.
In an index expression, the expression to the
left of the square brackets is evaluated before the expression inside
the square brackets.
In an expression that calls a method
through an object reference, the object reference is evaluated before
the argument expressions.
In any expression that calls
a method or constructor, the expressions supplied as the actual
arguments are evaluated from left to right.
In an array
allocation expression, the expressions that appear in square brackets
and provide the dimensions of the array are evaluated from left
to right.
The intent of all of these rules is to guarantee
that every implementation of Java evaluates any given expression
in the same way.[8]
In order to produce optimized code,
a Java compiler is allowed to deviate from the rules governing the
order in which operations are performed, provided that the result
is the same as if it had followed the rules.
[8] 
This is different than C/C++, which
leaves a number of details of expression evaluation up to an implementation,
such as the order in which the actual parameters of a function call
are evaluated.
References
Array Allocation Expressions;
Index Expressions;
Method Call Expression;
Object Allocation Expressions
Assignment Operators
Data Type of an Expression
 
 
 
 
 
 
 
